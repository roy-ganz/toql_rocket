#![feature(proc_macro_hygiene, decl_macro)]

#[macro_use]
extern crate rocket;


use rocket::{State,request::Form,http::Status};
use serde::{Serialize, Deserialize};

use rocket_db_pools::{Connection, Database};
use toql_mysql_async::MySqlAsync as Toql;
use toql::prelude::{CacheBuilder, query, fields, paths, ToqlApi};
use toql_rocket::prelude::{ToqlQuery, Counted, Result, };  // or simple toql_rocket::prelude::*

// Here comes our Todo item
// > Mapping from struct field names to database columns happens here automatically.
// > Mapping to Toql query fields happens here also automatically.
// > Table key(s) must be designated and must come first.  
// > Notice the `Toql` derive ---------------------v
#[derive(Debug, Serialize, Deserialize, PartialEq, Toql)]
pub struct Todo {

    #[serde(default)]
    #[toql(key)]  
    pub id: u64,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub completed: Option<bool>,
}
//
// Here come the CRUD functions
//

#[delete("/<id>")]
pub fn delete<'a>(id: u64, conn: Connection<ExampleDb>, cache: &State<Cache>) -> Result<Status> {
            
    let toql = Toql::from(conn.into_inner(), &*cache);
   
    // Delete an item
    // TodoKey is generated by the Toql derive
    let affected_rows= toql.delete_one(TodoKey::from(id)).await?;  

    Ok(
        if affected_rows == 0 {
            Status::NotFound
        } else {
            Status::NoContent
        }
    )
}

#[put("/<id>", data = "<todo>")]
pub async fn update(
    id: u64,
    mut todo: Json<Todo>,
    cache: &State<Cache>,
    conn: Connection<ExampleDb>,
) -> Result<Json<Todo>> {
        
    let toql = Toql::from(conn.into_inner(), &*cache);
  
    // Update all fields from a single entity taht have a value
    // fields!(top) = Check all fields for updates
    let affected_rows = toql.update_one(&todo.into_inner(), fields(top) ).await?; 

    // Load all fields from updated item
    let q = query!(Todo, "*, id eq ?", id);
    let u = toql.load_one(q)?;
    Ok(Json(u))
}

#[post("/", data = "<todo>")] 
pub async fn create<'a>(
    todo: Json<Todo>,
    cache: &State<Cache>,
    conn: Connection<ExampleDb>,
) -> Result<Json<Todo>> {
    
    let toql =Toql::from(conn.into_inner(), &*cache);

    // Insert one item
    // paths!(top) => Ignore all nested joins/merges, not important here
    // This will set the `id` to the generated value
    toql.insert_one(&todo.into_inner(), paths!(top)).await?; 

    // Load all fields from the created item
    let q = query!(Todo, "*, id eq ?", &todo.id);
    let u = toql.load_one(q)?; 
    Ok(Json(u))
}

#[get("/<id>")]
pub fn get(
    id: u64,
    cache: State<Cache>,
    conn: Connection<ExampleDb>,
) -> Result<Json<Todo>> {
    
    let toql = Toql::from(conn.into_inner(), &*cache);
   
    // Load all fields from this item 
    let q = query!(Todo, "*, id eq ?", id);
    let u = toql.load_one(q).await?;
    Ok(Json(u))
}

#[get("/?<toql_query..>")]
pub fn query(
    cache: State<Cache>,
    conn: Connection<ExampleDb>,
    toql_query: Form<ToqlQuery>,    // Fetch Toql query and page from URL query parameters
) -> Result<Counted<Json<Vec<Todo>>>> {
    
    let toql = Toql::from(conn.into_inner(), &*cache);

    // Parse query
    let (query, page) = toql_query.parse::<Todo>()?; 

    // Run query
    let r = toql.load_page(query, page)?;

    Ok(Counted(Json(r.0), r.1))
}

// The database connection
#[derive(Database)]
#[database("example_db")]
pub struct ExampleDb(mysql_async::Conn);



// Main to startup the server
fn main() {
    println!("------------------------------------------");
    println!("Full Toql CRUD example with Rocket and MySql");
    println!("------------------------------------------");
    println!("This example assumes that you have a MySql Server");
    println!("running with a database `example_db`");
    println!("Run the following SQL to create the table `Todo`");
    println!("CREATE TABLE `Todo` (`id` int(11) NOT NULL AUTO_INCREMENT,`title` varchar(200) NOT NULL, `completed` tinyint(1) PRIMARY KEY (id))");
    println!("------------------------------------------------------------------------------------------------------------");
    println!("Start the server with ");
    println!("ROCKET_DATABASES={{example_db={{url=mysql://USER:PASS@localhost:3306/example_db}}}} cargo +nightly run --example=\"crud_mysql\" --features=\"mysql\"");
    println!("----------------------------------------------------------------------------------------------------------------------");
    println!("Create a todo with `curl localhost:8000/todo -X POST -d '{{\"title\":\"Water plants\"}}'`");
    println!("Update a todo with `curl localhost:8000/todo/ID -X PUT -d '{{\"completed\":\"true\"}}'`");
    println!("Get a single todo with `curl localhost:8000/todo/ID`");
    println!("Get all todos with `curl localhost:8000/todo`");
    println!("Get only completed todos in descending order `curl localhost:8000/todo?query=-id,completed+eq+1`");
    println!("Delete a todo with `curl -X DELETE localhost:8000/todo/ID`");
    println!("--------------------------");



    // Keeps Toql mapping information
    let cache =  CacheBuilder::new().into_cache();
    
    rocket::ignite()
        .manage(cache)
        .attach(ExampleDb::init())
        .mount("/todo", routes![get, query, create, update, delete])
        .launch();
}


